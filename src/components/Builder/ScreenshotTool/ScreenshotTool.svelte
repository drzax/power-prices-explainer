<script lang="ts">
  import { untrack } from 'svelte';
  import JSZip from 'jszip';
  import { eachLimit } from 'async';
  import { Modal } from '@abcnews/components-builder';
  import saveAs from './saveAs.js';

  /* These will be replaced by imports in components-builder */

  type MarkerPrefixes = Record<string, string>;

  const defaultPrefixes: MarkerPrefixes = {
    'Scrolly mark': '#mark',
    'Scrolly opener': '#scrollytellerNAMEscrolly1',
    'Standalone graphic': '#graphic'
  };
  /* ======= end ====== */

  type GeneratorRequestConfig = {
    graphicLocation: URL;
    width: number;
    height: number;
  };

  interface Props {
    prefixes: MarkerPrefixes;
    screenshotWidth?: number;
    screenshotHeight?: number;
    maxParallelRequests?: number;
    getGraphicLocation?: (marker: MarkerDetails) => URL;
    getGeneratorRequest: (config: GeneratorRequestConfig) => Request;
  }

  type MarkerDetails = { name: string; prefix: string; data: string };

  /**
   * Takes a GeneratorRequestConfig object and returns a Request object that can be used to send a request to the
   * screenshot generator API.
   *
   * This default implementation makes the assumption that the screenshot capture service matches the API used by
   * https://fallback-automation.vercel.app.
   *
   * Most image generation/screenshot services have an API that takes at least URL, width, height. Some require using POST
   * requests, some require API authorization headers, etc. To use a different API, supply a function that returns a
   * Request object that matches the screenshot generation service's API.
   *
   * The `width` and `height` properties of the `config` parameter are the same values as those passed to the component
   * via `screenshotWidth` and `screenshotHeight` (or their defaults).
   *
   * @param {GeneratorRequestConfig} config A config object with information needed to generate the API Request
   * @param {URL}     config.graphicLocation  A URL to the location of the graphic to capture
   * @param {number}  config.width            The width of the viewport that should be used during graphic capture
   * @param {number}  config.height           The height of the viewport that should be used during graphic capture
   */
  const defaultGetGeneratorRequest = (config: GeneratorRequestConfig) => {
    const { graphicLocation, width, height } = config;
    const endpoint = new URL('https://fallback-automation.vercel.app/api');
    endpoint.searchParams.set('url', graphicLocation.toString());
    endpoint.searchParams.set('width', `${width}`);
    endpoint.searchParams.set('height', `${height}`);
    return new Request(endpoint);
  };

  /**
   * Takes a MarkerDetails object and returns a URL where the graphic generated by that marker is rendered.
   *
   * This default implementation makes the assumption that the graphic will be rendered at a URL that's the same as the
   * current page, but with the pathname and hash components modified in the following ways:
   * - Any 'builder' suffix on the path name is removed and 'iframe' is added.
   * - Any hash fragment is replaced with the `data` component of the marker (i.e. the marker string from the content
   *   with the prefix, defined in the `prefixes` component prop, removed.)
   *
   * @param marker A marker string decomposed into its constituent parts.
   */
  const defaultGetGraphicLocation = (marker: MarkerDetails): URL => {
    const location = document.location;
    const url = new URL(location.href);
    url.pathname = url.pathname.replace(/(builder\/?)?$/, 'iframe');
    url.hash = `#${marker.data}`;
    return url;
  };

  let {
    prefixes = defaultPrefixes,
    getGeneratorRequest = defaultGetGeneratorRequest,
    getGraphicLocation = defaultGetGraphicLocation,
    screenshotWidth = 800,
    screenshotHeight = 600,
    maxParallelRequests = 3
  }: Props = $props();

  // closed => pasting => preview => generate => done | error
  let status: 'closed' | 'pasting' | 'preview' | 'generate' | 'done' | 'error' = $state('closed');
  let pastedState: string = $state('');
  let progress = $state(0);
  let error = $state('');

  let extractedMarkers = $derived.by(() => {
    return pastedState
      .split('\n')
      .flatMap(line => {
        const matchingPrefix = Object.entries(prefixes).find(([_, prefix]) => line.startsWith(prefix));
        return typeof matchingPrefix === 'undefined'
          ? []
          : [
              {
                name: matchingPrefix[0],
                prefix: matchingPrefix[1],
                data: line.substring(matchingPrefix[1].length)
              }
            ];
      })
      .filter((d, i, arr) => arr.findIndex(dd => dd.data === d.data) === i);
  });

  async function doFetch(req: Request) {
    const response = await fetch(req);
    if (response.status !== 200) {
      throw new Error(`${response.status}: ${response.statusText}`);
    }
    return response.blob();
  }

  async function sleep(seconds: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, seconds));
  }

  function retrier(maxAttempts: number) {
    let attempt = 0;
    return async function retry<T extends () => Promise<any>>(fn: T): Promise<Awaited<ReturnType<T>>> {
      try {
        return await fn();
      } catch (e) {
        if (attempt >= maxAttempts) throw e;
        attempt++;
        const ms = 1000 * 2 * attempt;
        console.log(`Retry attempt #${attempt + 1} waiting ${ms} milliseconds`);
        await sleep(ms);
        return retry(fn);
      }
    };
  }

  async function createScreenshots(markers: MarkerDetails[]) {
    const zip = new JSZip();
    let completed = 0;
    // Put a little bit in the bar at the start so it's clear what it is.
    progress = 0.5 / markers.length;
    error = '';
    const results: (Blob | null)[] = [];
    // The weird noop callback here is required due to a limitation of the async library in the (compiled) svelte context. See: https://caolan.github.io/async/v3/global.html
    await eachLimit(markers, maxParallelRequests, async (marker: MarkerDetails, callback: () => void) => {
      const retry = retrier(3);
      const result = await retry(() =>
        doFetch(
          getGeneratorRequest({
            graphicLocation: getGraphicLocation(marker),
            width: screenshotWidth,
            height: screenshotHeight
          })
        )
      ).catch(e => null);

      completed += 1;
      progress = completed / markers.length;
      results.push(result);
      callback();
    });

    const errors: string[] = [];
    results.forEach((blobOrNull, index) => {
      const filename = `${String(index).padStart(3, '0')}-${markers[index].name}.png`;
      if (blobOrNull) {
        zip.file(filename, blobOrNull);
      } else {
        errors.push(filename);
      }
    });

    if (errors.length) {
      if (errors.length === results.length) {
        error = 'Could not download files. The fallback service may not be running.';
        return;
      } else if (errors.length) {
        error =
          'Error: could not download some files. These might be missing from the zip:\n\n → ' + errors.join('\n → ');
      }
      status = 'error';
    }

    return zip.generateAsync({ type: 'blob' }).then(content => {
      if (!errors.length) {
        status = 'done';
      }
      saveAs(content, `fallback-bundle-${Date.now()}.zip`);
    });
  }

  // When the user first hits the "generate" screen, call createScreenshot()
  $effect(() => {
    if (status === 'generate') {
      createScreenshots(untrack(() => extractedMarkers));
    }
  });

  function onClose() {
    status = 'closed';
  }
</script>

<button
  onclick={e => {
    e.preventDefault();
    status = 'pasting';
    pastedState = '';
  }}
>
  Screenshot tool
</button>

{#snippet footerChildren()}
  {#if status === 'preview'}
    <button
      onclick={e => {
        e.preventDefault();
        status = 'pasting';
      }}
    >
      Back
    </button>
  {/if}
  <button
    disabled={status === 'generate'}
    onclick={e => {
      e.preventDefault();
      switch (status) {
        case 'error':
          status = 'closed';
          return;
        case 'pasting':
          status = 'preview';
          return;
        case 'preview':
          status = 'generate';
          return;
        default:
          status = 'closed';
      }
    }}
  >
    {#if status === 'preview'}
      Generate screenshots
    {:else if status === 'error' || status === 'done'}
      Close
    {:else}
      Next
    {/if}
  </button>
{/snippet}

{#if status !== 'closed'}
  <Modal title="Screenshot tool" {onClose} {footerChildren}>
    <div class="screenshot-tool">
      {#if status === 'pasting'}
        <p>Paste your story, or a series of markers to create screenshots</p>
        <textarea bind:value={pastedState} placeholder="#markVER1"></textarea>
      {/if}

      {#if status === 'preview'}
        <p>
          This will create {extractedMarkers.length} screenshot{extractedMarkers.length === 1 ? '' : 's'}:
        </p>
        <table class="builder__table">
          <thead>
            <tr><th>#</th><th>Marker</th><th>Data</th></tr>
          </thead>
          <tbody>
            {#each extractedMarkers as { name, data }, i}
              <tr><td>{i + 1}</td><td>{name}</td><td><code class="marker">{data}</code></td></tr>
            {/each}
          </tbody>
        </table>
      {/if}

      {#if status === 'generate'}
        <p>Generating screenshots. This may take some time.</p>
        <progress max="100" value={Math.round(progress * 100)}></progress>
      {/if}

      {#if status === 'error'}
        <p>{error}</p>
      {/if}

      {#if status === 'done'}
        <p>Your screenshots are finished. Check for the zip file in your Downloads folder.</p>
      {/if}
    </div>
  </Modal>
{/if}

<style>
  .screenshot-tool {
    width: 100vw;
    max-width: 640px;
    position: relative;
    height: 100vh;
    max-height: 200px;
  }
  textarea {
    min-height: 150px;
  }
  table {
    max-width: 100%;
    th {
      text-align: left;
    }
    td {
      overflow: scroll;
    }
  }
  table,
  progress,
  textarea {
    width: calc(100% - 2px);
  }
  table {
    max-width: calc(100% - 2px);
  }

  .marker {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    display: block;
    max-width: 20em;
  }
</style>
